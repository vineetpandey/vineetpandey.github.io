{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to My Docs \u00b6 For full documentation visit mkdocs.org . Commands \u00b6 mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout \u00b6 mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-my-docs","text":"For full documentation visit mkdocs.org .","title":"Welcome to My Docs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"about/","text":"Welcome to My Docs \u00b6 For full documentation visit mkdocs.org . Commands \u00b6 mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout \u00b6 mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"About"},{"location":"about/#welcome-to-my-docs","text":"For full documentation visit mkdocs.org .","title":"Welcome to My Docs"},{"location":"about/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"about/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"tags/","text":"","title":"Tags"},{"location":"pages/tutorial/SecuringGitLabCICDwithAWSOIDC/SecuringGitLabCICDwithAWSOIDC/","text":"Securing AWS from GitLab CI with OIDC \u00b6 Problem Statement - \u00b6 With Gitlab CI/CD, key rotation is a major challenge for any organisation since there is not about just one repository to handle but could be many CIS benchmark for AWS recommends to rotate the credentials every 90 days to safeguard the secrets Tracking and rotating the keys - since there could be multiple repositories and chances of missing out on credentials rotation would be pretty high Also, there could be multiple repercussions & use-cases that can have differing views with different needs. So, this list can potentially be huge in the real world Solution Concept - \u00b6 To get rid of this key rotation headache, let's move to OIDC supported by AWS OIDC (OpenID Connect) is an authentication layer on top of the OAuth 2.0 framework. It is used to authenticate identities with an external identity provider No involvement of keys therefore no such pain of key management AWS provides support to create and manage an OIDC provider such as facebook, google, etc. How to Configure \u00b6 Configuring AWS \u00b6 Search for IAM in AWS services and open the IAM console. Click on the \u201cIdentity providers\u201d section at left Now, click over the \u201cAdd provider\u201d option Now configure OpenID Connect. Provider URL: This is the URL of the GitLab instance. For self-hosted versions, fill-in your GitLab hosted domain. While for SaaS hosted Gitlab, the URL is https://gitlab.com Then, click on \u201cGet thumbprint\u201d to retrieve the thumbprint/hash of the provider\u2019s certificate Audience: Same as the Provider URL. In our case, it is https://gitlab.com Finally, click on \u201cAdd provider\u201d And, provider will start appearing under the \u201cIdentity providers\u201d section Now go to policies section under IAM and create a policy Copy & Paste the below snippet within the policy { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Sid\": \"GitLabOIDCPolicy\", \"Effect\": \"Allow\", \"Action\": \"sts:GetCallerIdentity\", \"Resource\": \"*\" } ] } Click \u201cNext\u201d until the \u201cReview Policy\u201d page. Then give a name of choice, for example I gave - Gitlab-OIDC-Policy. And click \"Create policy\" And, the newly created policy will start appearing under the Policies list Now, go to the \u201cRoles\u201d section in the IAM console and click on \u201cCreate role\u201d. Then choose \u201cWeb identity\u201d option and opt for the Identity provider and audience created in the previous step (1.3) & click \u201cNext\u201d Attach the policy created in previous step (1.8) with the role and click \u201cNext\u201d Then give a name of your choice, for example I gave \u201cGitLab-OIDC-Role\u201d & review and click on \u201cCreate role\u201d And, this will start appearing in \u201cRoles\u201d dashboard Since, we\u2019ve created an OIDC role but again this poses a security threat. Technically, any GitLab user would be able to assume this role. So, we need to put restrictions by adding down the conditions within the trust document Now, go to the \u201cTrust relationships\u201d tab under the created role (step 1.12) and click on \u201cEdit trust policy\u201d And, append the below snippet in the trust policy and click over \u201cUpdate Policy\u201d { \"Condition\": { \"StringEquals\": { \"gitlab.com:sub\": \"project_path:mygroup/myproject:ref_type:branch:ref:main\" } } } More fields to be used in the condition can be found here And, final trust policy would be like - { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"Federated\": \"arn:aws:iam::xxxxxxxxxxx:oidc-provider/gitlab.com\" }, \"Action\": \"sts:AssumeRoleWithWebIdentity\", \"Condition\": { \"StringEquals\": { \"gitlab.com:aud\": \"https://gitlab.com\", \"gitlab.com:sub\": \"project_path:vineetp/sample_oidc_proj:ref_type:branch:ref:main\" } } } ] } Configuring AWS OIDC in GitLab \u00b6 Now we are done with configuring AWS OIDC. It\u2019s time to head over to GitLab to configure the project for retrieving the temporary credentials from AWS STS (Security Token Service). Follow below steps to configure the GitLab correctly. Open the GitLab Project repository you want to configure and go to Settings -> CI/CD -> Variables -> Add variable Now, Add the \u201cROLE_ARN\u201d variable in the GitLab. And, value of this \u201cROLE_ARN\u201d variable should be the arn of the previously created OIDC role (step 1.12) arn:aws:iam::XYXYYXYXYXY:role/GitLab-OIDC-Role There is another variable called \u201cCI_JOB_JWT_V2\u201d and is predefined by GitLab. CI_JOB_JWT_V2 would allow AWS OIDC and other providers to leverage GitLab's CI JWT Token to authenticate a pipeline job. Now, add the below snippet to your jobs in .gitlab-ci.yml file to retrieve temporary short-lived credentials assume role: script: - > STS=$(aws sts assume-role-with-web-identity --role-arn arn:aws:iam::XYXYXYXYXYXY:role/GitLab-OIDC-Role --role-session-name \"GitLabRunner-${CI_PROJECT_ID}-${CI_PIPELINE_ID}\" --web-identity-token $CI_JOB_JWT_V2 --duration-seconds 3600 --query 'Credentials.[AccessKeyId,SecretAccessKey,SessionToken]' --output text) - export AWS_ACCESS_KEY_ID=$(echo $STS | cut -d' ' -f1) - export AWS_SECRET_ACCESS_KEY=$(echo $STS | cut -d' ' -f2) - export AWS_SESSION_TOKEN=$(echo $STS | cut -d' ' -f3) My sample .gitlab-ci.yml file look like below. You can customise as per your needs Sample pipeline output will look like below Conclusion \u00b6 By configuring the short-lived credentials, now we don\u2019t have to worry about the rotation and security of statically stored AWS credentials. And should be able to carry out the necessary activities such as running Terraform scripts, etc. in the AWS account from GitLab. On high level, there are 5 major steps for OIDC configuration that we have to carry out - 1. Configure Identity Provider in AWS 2. Create an AWS Policy for your GitLab OIDC 3. Create an AWS role and attach the created policy in that role 4. Configure the trust relationship in the role so as to restrict the unintended access 5. Finally configure the OIDC role in GitLab and retrieve the temporary set of credentials to perform actions References \u00b6 https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_create_oidc.html https://docs.gitlab.com/ee/ci/cloud_services/aws/ https://docs.gitlab.com/ee/ci/variables/predefined_variables.html","title":"Securing AWS from GitLab CI with OIDC"},{"location":"pages/tutorial/SecuringGitLabCICDwithAWSOIDC/SecuringGitLabCICDwithAWSOIDC/#securing-aws-from-gitlab-ci-with-oidc","text":"","title":"Securing AWS from GitLab CI with OIDC"},{"location":"pages/tutorial/SecuringGitLabCICDwithAWSOIDC/SecuringGitLabCICDwithAWSOIDC/#problem-statement-","text":"With Gitlab CI/CD, key rotation is a major challenge for any organisation since there is not about just one repository to handle but could be many CIS benchmark for AWS recommends to rotate the credentials every 90 days to safeguard the secrets Tracking and rotating the keys - since there could be multiple repositories and chances of missing out on credentials rotation would be pretty high Also, there could be multiple repercussions & use-cases that can have differing views with different needs. So, this list can potentially be huge in the real world","title":"Problem Statement -"},{"location":"pages/tutorial/SecuringGitLabCICDwithAWSOIDC/SecuringGitLabCICDwithAWSOIDC/#solution-concept-","text":"To get rid of this key rotation headache, let's move to OIDC supported by AWS OIDC (OpenID Connect) is an authentication layer on top of the OAuth 2.0 framework. It is used to authenticate identities with an external identity provider No involvement of keys therefore no such pain of key management AWS provides support to create and manage an OIDC provider such as facebook, google, etc.","title":"Solution Concept -"},{"location":"pages/tutorial/SecuringGitLabCICDwithAWSOIDC/SecuringGitLabCICDwithAWSOIDC/#how-to-configure","text":"","title":"How to Configure"},{"location":"pages/tutorial/SecuringGitLabCICDwithAWSOIDC/SecuringGitLabCICDwithAWSOIDC/#configuring-aws","text":"Search for IAM in AWS services and open the IAM console. Click on the \u201cIdentity providers\u201d section at left Now, click over the \u201cAdd provider\u201d option Now configure OpenID Connect. Provider URL: This is the URL of the GitLab instance. For self-hosted versions, fill-in your GitLab hosted domain. While for SaaS hosted Gitlab, the URL is https://gitlab.com Then, click on \u201cGet thumbprint\u201d to retrieve the thumbprint/hash of the provider\u2019s certificate Audience: Same as the Provider URL. In our case, it is https://gitlab.com Finally, click on \u201cAdd provider\u201d And, provider will start appearing under the \u201cIdentity providers\u201d section Now go to policies section under IAM and create a policy Copy & Paste the below snippet within the policy { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Sid\": \"GitLabOIDCPolicy\", \"Effect\": \"Allow\", \"Action\": \"sts:GetCallerIdentity\", \"Resource\": \"*\" } ] } Click \u201cNext\u201d until the \u201cReview Policy\u201d page. Then give a name of choice, for example I gave - Gitlab-OIDC-Policy. And click \"Create policy\" And, the newly created policy will start appearing under the Policies list Now, go to the \u201cRoles\u201d section in the IAM console and click on \u201cCreate role\u201d. Then choose \u201cWeb identity\u201d option and opt for the Identity provider and audience created in the previous step (1.3) & click \u201cNext\u201d Attach the policy created in previous step (1.8) with the role and click \u201cNext\u201d Then give a name of your choice, for example I gave \u201cGitLab-OIDC-Role\u201d & review and click on \u201cCreate role\u201d And, this will start appearing in \u201cRoles\u201d dashboard Since, we\u2019ve created an OIDC role but again this poses a security threat. Technically, any GitLab user would be able to assume this role. So, we need to put restrictions by adding down the conditions within the trust document Now, go to the \u201cTrust relationships\u201d tab under the created role (step 1.12) and click on \u201cEdit trust policy\u201d And, append the below snippet in the trust policy and click over \u201cUpdate Policy\u201d { \"Condition\": { \"StringEquals\": { \"gitlab.com:sub\": \"project_path:mygroup/myproject:ref_type:branch:ref:main\" } } } More fields to be used in the condition can be found here And, final trust policy would be like - { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"Federated\": \"arn:aws:iam::xxxxxxxxxxx:oidc-provider/gitlab.com\" }, \"Action\": \"sts:AssumeRoleWithWebIdentity\", \"Condition\": { \"StringEquals\": { \"gitlab.com:aud\": \"https://gitlab.com\", \"gitlab.com:sub\": \"project_path:vineetp/sample_oidc_proj:ref_type:branch:ref:main\" } } } ] }","title":"Configuring AWS"},{"location":"pages/tutorial/SecuringGitLabCICDwithAWSOIDC/SecuringGitLabCICDwithAWSOIDC/#configuring-aws-oidc-in-gitlab","text":"Now we are done with configuring AWS OIDC. It\u2019s time to head over to GitLab to configure the project for retrieving the temporary credentials from AWS STS (Security Token Service). Follow below steps to configure the GitLab correctly. Open the GitLab Project repository you want to configure and go to Settings -> CI/CD -> Variables -> Add variable Now, Add the \u201cROLE_ARN\u201d variable in the GitLab. And, value of this \u201cROLE_ARN\u201d variable should be the arn of the previously created OIDC role (step 1.12) arn:aws:iam::XYXYYXYXYXY:role/GitLab-OIDC-Role There is another variable called \u201cCI_JOB_JWT_V2\u201d and is predefined by GitLab. CI_JOB_JWT_V2 would allow AWS OIDC and other providers to leverage GitLab's CI JWT Token to authenticate a pipeline job. Now, add the below snippet to your jobs in .gitlab-ci.yml file to retrieve temporary short-lived credentials assume role: script: - > STS=$(aws sts assume-role-with-web-identity --role-arn arn:aws:iam::XYXYXYXYXYXY:role/GitLab-OIDC-Role --role-session-name \"GitLabRunner-${CI_PROJECT_ID}-${CI_PIPELINE_ID}\" --web-identity-token $CI_JOB_JWT_V2 --duration-seconds 3600 --query 'Credentials.[AccessKeyId,SecretAccessKey,SessionToken]' --output text) - export AWS_ACCESS_KEY_ID=$(echo $STS | cut -d' ' -f1) - export AWS_SECRET_ACCESS_KEY=$(echo $STS | cut -d' ' -f2) - export AWS_SESSION_TOKEN=$(echo $STS | cut -d' ' -f3) My sample .gitlab-ci.yml file look like below. You can customise as per your needs Sample pipeline output will look like below","title":"Configuring AWS OIDC in GitLab"},{"location":"pages/tutorial/SecuringGitLabCICDwithAWSOIDC/SecuringGitLabCICDwithAWSOIDC/#conclusion","text":"By configuring the short-lived credentials, now we don\u2019t have to worry about the rotation and security of statically stored AWS credentials. And should be able to carry out the necessary activities such as running Terraform scripts, etc. in the AWS account from GitLab. On high level, there are 5 major steps for OIDC configuration that we have to carry out - 1. Configure Identity Provider in AWS 2. Create an AWS Policy for your GitLab OIDC 3. Create an AWS role and attach the created policy in that role 4. Configure the trust relationship in the role so as to restrict the unintended access 5. Finally configure the OIDC role in GitLab and retrieve the temporary set of credentials to perform actions","title":"Conclusion"},{"location":"pages/tutorial/SecuringGitLabCICDwithAWSOIDC/SecuringGitLabCICDwithAWSOIDC/#references","text":"https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_create_oidc.html https://docs.gitlab.com/ee/ci/cloud_services/aws/ https://docs.gitlab.com/ee/ci/variables/predefined_variables.html","title":"References"},{"location":"tags/","text":"","title":"Tags"}]}